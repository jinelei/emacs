* 第一部分 走进java
** 第一章 走进java
*** 概述
*** Java技术体系
 Sun官方定义的Java技术体系包括
 - Java 程序设计语言
 - 各种引荐平台上的Java虚拟机
 - Class文件格式
 - Java API类库
 - 来自商业机构和开源社区的第三方Java类库
 我们可以吧Java程序设计语言、java虚拟机、Java API类库这三部分构成*JDK*，Java API类库中的Java SE API子集和Java虚拟机统称为JRE。
*** Java发展史
 - 1995年5月23日：Oak语言改名为Java，并且在SunWorld大会上正式发布Java 1.0版本。
 - 1996年月23日：JDK 1.0发布，提供了一个春节是执行的java虚拟机时间（Sun Classic VM）。JDK1.0版本代表即使包括Java虚拟机、Applet、AWT。
*** java虚拟机发展史
**** Sun Classic / Exact VM
**** Sun HotSpot VM
**** Sun Mobile-Embedded VM/ Meta-Circular VM
**** BEA JRockit / IBM J9 VM
**** Azul VM / BEA Liquid VM
**** Apache Harmony / Google Android Dalvik VM
**** Microsoft JVM
*** 展望java技术的未来
**** 模块化
**** 混合语言
**** 多核并行
**** 进一步丰富语法
**** 64位虚拟机
*** 实战：自己编译JDK
**** 获取JDK源码
**** 系统需求
**** 构建比那一环境
**** 尽享编译
**** 在IDE工具中进行源码调试
*** 本章小结
* 第二部分 自动内存管理机制
** 第二章 java内存区域与内存溢出异常
*** 概述
*** 运行时数据区域
**** 程序计数器
**** java虚拟机栈
**** 本地方法栈
**** java堆
**** 方法区
**** 运行时常量池
**** 直接内存
*** HotSpot虚拟机对象探秘
**** 对象的创建
**** 对象的内存布局
**** 对象的访问定位
*** OutOfMemoryError异常
**** java堆溢出
**** 虚拟机栈和本地方法栈溢出
**** 方法区和运行是常量池溢出
**** 本机直接内存溢出
*** 本章小结
** 第三章 垃圾收集器与内存分配策略
*** 概述
*** 对象已死吗
**** 引用计数算法
**** 可达性分析算法
**** 再谈引用
**** 生存还是死亡
**** 回收方法区
*** 垃圾手机算法
**** 标记-清除算法
**** 复制算法
**** 标记-整理算法
**** 分代收集算法
*** HotSpot的算法实现
**** 枚举根节点
**** 安全点
**** 安全区域
*** 垃圾收集器
**** Serial收集器
**** ParNew收集器
**** Parallel Scavenge收集器
**** Serial Old收集器
**** Parallel Old收集器
**** CMS收集器
**** G1收集器
**** 理解GpC日志
**** 垃圾收集器参数总结
*** 内存分配与回收策略
**** 对象有限在Eden分配
**** 大对象直接进入老年代
**** 长期存活的对象经进入老年代
**** 动态对象年龄判定
**** 空间分配担保
*** 本章小结
** 第四章 虚拟机性能监控与故障处理工具
*** 概述
*** JDK命令行工具
**** jps：虚拟机进程状态工具
**** jstat：虚拟机统计信息见识工具
**** jinfo：java配置信息工具
**** jmap：java内存映像工具
**** jhat：虚拟机堆转储快照分析工具
**** jstack：java堆栈跟踪工具
**** HSDIS：JIT生成代码反汇编
*** JDK可视化工具
**** JConsole：java监视与管理控制台
**** VisualVM：多合一故障处理工具
*** 本章小结
** 第五章 优化案例分析与实战
*** 概述
*** 案例分析
**** 高性能硬件上的程序部署策略
**** 集群间同步导致内存溢出
**** 对外内存导致的内存溢出
**** 外部命令导致系统缓慢
**** 服务器JVM进程崩溃
**** 不恰当数据结构导致内存占用过大
**** 有windows虚拟内存导致的长时间停顿
*** 实战：Eclipse运行速度优化
**** 调优钱的程序运行状态
**** 升级JDK1.6的性能变化及兼容性问题
**** 编译时间和类加载时间的变化
**** 调整内存设置控制垃圾收集频率
**** 选择收集器降低延迟
*** 本章小结
* 第三部分 虚拟机执行子系统
** 第六章 类文件结构
*** 概述
*** 无关性的基石
*** Class类文件的结构
**** 魔数与Class文件的版本
**** 常量池
**** 访问标志
**** 类索引、父类索引与接口索引集合
**** 字段表集合
**** 方法表集合
**** 属性表集合
*** 字节码指令简介
**** 字节码与数据类型
**** 加载和存储指令
**** 运算指令
**** 类型转换指令
**** 对象穿件与访问指令 
**** 操作数栈管理指令ppp
**** 控制转移指令
**** 方法调用和返回指令
**** 异常处理指令
**** 同步指令
**** 公有设计和私有实现
**** Class文件结构的发展
**** 本章小结
** 第七章 虚拟机累加载机制
*** 概述
*** 类加载的时机
*** 类加载的过程
**** 加载
**** 验证
**** 准备
**** 解析
**** 初始化
*** 类加载器
**** 类与类加载器
**** 双亲委派模型
**** 破坏双亲委派模型
*** 本章小结
** 第八章 虚拟机字节码执行引擎
*** 概述
*** 运行时栈帧结构
**** 局部变量表
**** 操作数栈
**** 动态连接
**** 方法返回地址
**** 附加信息
*** 方法调用
**** 解析
**** 分派
**** 动态类型语言支持
*** 基于栈的字节码解释执行引擎
**** 解释执行
**** 基于栈的指令集与基于寄存器的指令集
**** 基于栈的解释器执行过程
**** 本章小结
** 第九章 类加载及执行子系统的案例与实战
*** 概述
*** 案例分析
**** Tomcat：正统的类加载器架构
**** OSGi灵活的类加载器架构
**** 字节码生成技术与动态代理的实现
**** Retrotranslator：跨越JDK版本
*** 实战：自己动手实现远程执行功能
**** 目标
**** 思路
**** 实现
**** 验证
*** 本章小结
* 第四部分 程序编译与代码优化
** 第十章 早期（编译期）优化
*** 概述
*** javac编译器
**** javac的源码与调试
**** 解析与填充符号表
**** 注解处理器
**** 语义分析与字节码生成
*** java语法糖的味道
**** 泛型与类型擦除
**** 自动装箱、拆箱与遍历循环
**** 条件编译
*** 实战：插入式注解处理器
**** 实战目标
**** 代码实现
**** 运行与测试
**** 其他应用案例
** 第十一章 晚期（运行期）优化
*** 概述
*** HotSpot虚拟机内的即时编译器
**** 解释器与编译器
**** 编译对象与触发条件
**** 编译过程
**** 查看及分析即时编译结果
*** 编译优化技术
**** 优化技术概览
**** 公共子表达式消除
**** 数组便捷检查消除
**** 方法内联
**** 逃逸分析
*** Java与C/C++的编译器对比
*** 本章小结
* 第五部分 高效并发
** 第十二章 java内存模型与线程
*** 概述
*** 硬件的效率与一致性
*** java内存模型
**** 主内存与工作内存
Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量与java编程中的变量有所区别，它包括实例字段、静态字段和构成数组对象的原色，但不包括局部变量与方法参数，因为后者是县城私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，java内存模型并没有限制执行引擎使用处理器的特定寄存器或魂村来和主内存进行交互，也没有先充值即时编译器进行调整代码执行顺序这类优化措施。
Java内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存，县城的工作内存保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程见变量的传递据需要通过主内存来完成。
**** 内存间交互操作
关于主内存与工作内存之间具体的交互协议，几一个变量如何从主内存拷贝到工作内存、如何从工作内存会主内存之类的细节实现，java内存中定义了一下巴中操作累完成，虚拟机实现是必须保证下面体积的每一种操作都是院子的、不可再分的（对于都变了、龙类型的变量来书哦，load、store、read和write操作在某些平台上允许例外）
- lock：作用于主内存的变量，它吧一个变量表示为一条线程独占的状态
- unlock：左右于主内存的变量，他把一个处于锁定状态的变量释放出来，释放后的变量才可以可以被其他线程锁定。
- read：作用于主内存的变量，他把一个变量的只从主内存传输到线程的工作内存中，以便随后的load动作使用。
- load：作用于工作内存的变量，他把read操作从主内存中得到的变量只放入工作内存的变量副本中。
- use：作用于工作内存的变量，他把工作内存中一个变量的只传递给执行引擎，每当虚拟机遇到一个需要使用到变量的只的字节码指令是将会执行这个操作。
- assign：作用于工作内存的变量，他把一个执行引擎接受到的值赋给工作北村的变量，每当虚拟机遇到一个给变量赋值的字节码指令是执行这个操作。
- store：作用于工作内存的变量，他把一个变量的值传输到主内存中，以便随后的write使用。
- write：作用于主内存的变量，他把store操作从工作内存中得到的变量的值放入主内存的变量中。
如果要把一个变量从主内存复制到工作内存，那就要顺序的执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序的执行store和write操作。
Java内存模型要求read、laod和store、write成对出现，但不要求连续出现；但是java内存模型也制定了一下规则必须满足：
- 不允许read和load、store和write之一单独出现。
- 不允许一个线程丢弃它最近的assign操作，记载工作内存中改变了之后必须把该变化同步回主内存。
- 不允许一个线程无原因的（没有发生任何assign）把数据从工作线程同步回主内存中。
- 一个新的变量只能在主内存中诞生，不允许工作内存中直接使用一个未被初始化（（load或者assign）的变量，也就是use、store之前必须有laod或者assign。
- 一个变量在同意时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，稍后的unlcok也要求相应的次数。
- 如果对一个变量执行lock操作，那么将会清空工作内存中此变量的值，子啊执行疫情使用这个变量前，需要重新执行load或assign操作初始化变量的值。
- 如果对一个变量实现没有被lock操作锁定，那就不允许对他执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中。
**** 对于volatile型变量的特殊规则
**** 对于long和double型变量的特殊规则
**** 原子性、可见性与有序性
**** 先行发生原则
*** java与线程
**** 线程的实现
**** java线程的调度
**** 状态转换
*** 本章小结
** 第十三章 线程安全与锁优化
*** 概述
*** 线程安全
**** java语言中的线程安全
**** 线程安全的实现方法
*** 锁优化
**** 自旋锁与自适应自旋锁
**** 锁消除
**** 锁粗话
**** 轻量级锁
**** 偏向锁
*** 本章小结
