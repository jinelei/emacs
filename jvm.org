* 第一部分 走进java
** 第一章 走进java
*** 概述
*** Java技术体系
 Sun官方定义的Java技术体系包括
 - Java 程序设计语言
 - 各种引荐平台上的Java虚拟机
 - Class文件格式
 - Java API类库
 - 来自商业机构和开源社区的第三方Java类库
 我们可以吧Java程序设计语言、java虚拟机、Java API类库这三部分构成*JDK*，Java API类库中的Java SE API子集和Java虚拟机统称为JRE。
*** Java发展史
 - 1995年5月23日：Oak语言改名为Java，并且在SunWorld大会上正式发布Java 1.0版本。
 - 1996年月23日：JDK 1.0发布，提供了一个春节是执行的java虚拟机时间（Sun Classic VM）。JDK1.0版本代表即使包括Java虚拟机、Applet、AWT。
*** java虚拟机发展史
**** Sun Classic / Exact VM
**** Sun HotSpot VM
**** Sun Mobile-Embedded VM/ Meta-Circular VM
**** BEA JRockit / IBM J9 VM
**** Azul VM / BEA Liquid VM
**** Apache Harmony / Google Android Dalvik VM
**** Microsoft JVM
*** 展望java技术的未来
**** 模块化
**** 混合语言
**** 多核并行
**** 进一步丰富语法
**** 64位虚拟机
*** 实战：自己编译JDK
**** 获取JDK源码
**** 系统需求
**** 构建比那一环境
**** 尽享编译
**** 在IDE工具中进行源码调试
*** 本章小结
* 第二部分 自动内存管理机制
** 第二章 java内存区域与内存溢出异常
*** 概述
*** 运行时数据区域
**** 程序计数器
**** java虚拟机栈
**** 本地方法栈
**** java堆
**** 方法区
**** 运行时常量池
**** 直接内存
*** HotSpot虚拟机对象探秘
**** 对象的创建
**** 对象的内存布局
**** 对象的访问定位
*** OutOfMemoryError异常
**** java堆溢出
**** 虚拟机栈和本地方法栈溢出
**** 方法区和运行是常量池溢出
**** 本机直接内存溢出
*** 本章小结
** 第三章 垃圾收集器与内存分配策略
*** 概述
*** 对象已死吗
**** 引用计数算法
**** 可达性分析算法
**** 再谈引用
**** 生存还是死亡
**** 回收方法区
*** 垃圾手机算法
**** 标记-清除算法
**** 复制算法
**** 标记-整理算法
**** 分代收集算法
*** HotSpot的算法实现
**** 枚举根节点
**** 安全点
**** 安全区域
*** 垃圾收集器
**** Serial收集器
**** ParNew收集器
**** Parallel Scavenge收集器
**** Serial Old收集器
**** Parallel Old收集器
**** CMS收集器
**** G1收集器
**** 理解GpC日志
**** 垃圾收集器参数总结
*** 内存分配与回收策略
**** 对象有限在Eden分配
**** 大对象直接进入老年代
**** 长期存活的对象经进入老年代
**** 动态对象年龄判定
**** 空间分配担保
*** 本章小结
** 第四章 虚拟机性能监控与故障处理工具
*** 概述
*** JDK命令行工具
**** jps：虚拟机进程状态工具
**** jstat：虚拟机统计信息见识工具
**** jinfo：java配置信息工具
**** jmap：java内存映像工具
**** jhat：虚拟机堆转储快照分析工具
**** jstack：java堆栈跟踪工具
**** HSDIS：JIT生成代码反汇编
*** JDK可视化工具
**** JConsole：java监视与管理控制台
**** VisualVM：多合一故障处理工具
*** 本章小结
** 第五章 优化案例分析与实战
*** 概述
*** 案例分析
**** 高性能硬件上的程序部署策略
**** 集群间同步导致内存溢出
**** 对外内存导致的内存溢出
**** 外部命令导致系统缓慢
**** 服务器JVM进程崩溃
**** 不恰当数据结构导致内存占用过大
**** 有windows虚拟内存导致的长时间停顿
*** 实战：Eclipse运行速度优化
**** 调优钱的程序运行状态
**** 升级JDK1.6的性能变化及兼容性问题
**** 编译时间和类加载时间的变化
**** 调整内存设置控制垃圾收集频率
**** 选择收集器降低延迟
*** 本章小结
* 第三部分 虚拟机执行子系统
** 第六章 类文件结构
*** 概述
*** 无关性的基石
*** Class类文件的结构
**** 魔数与Class文件的版本
**** 常量池
**** 访问标志
**** 类索引、父类索引与接口索引集合
**** 字段表集合
**** 方法表集合
**** 属性表集合
*** 字节码指令简介
**** 字节码与数据类型
**** 加载和存储指令
**** 运算指令
**** 类型转换指令
**** 对象穿件与访问指令 
**** 操作数栈管理指令ppp
**** 控制转移指令
**** 方法调用和返回指令
**** 异常处理指令
**** 同步指令
**** 公有设计和私有实现
**** Class文件结构的发展
**** 本章小结
** 第七章 虚拟机累加载机制
*** 概述
*** 类加载的时机
*** 类加载的过程
**** 加载
**** 验证
**** 准备
**** 解析
**** 初始化
*** 类加载器
**** 类与类加载器
**** 双亲委派模型
**** 破坏双亲委派模型
*** 本章小结
** 第八章 虚拟机字节码执行引擎
*** 概述
*** 运行时栈帧结构
**** 局部变量表
**** 操作数栈
**** 动态连接
**** 方法返回地址
**** 附加信息
*** 方法调用
**** 解析
**** 分派
**** 动态类型语言支持
*** 基于栈的字节码解释执行引擎
**** 解释执行
**** 基于栈的指令集与基于寄存器的指令集
**** 基于栈的解释器执行过程
**** 本章小结
** 第九章 类加载及执行子系统的案例与实战
*** 概述
*** 案例分析
**** Tomcat：正统的类加载器架构
**** OSGi灵活的类加载器架构
**** 字节码生成技术与动态代理的实现
**** Retrotranslator：跨越JDK版本
*** 实战：自己动手实现远程执行功能
**** 目标
**** 思路
**** 实现
**** 验证
*** 本章小结
* 第四部分 程序编译与代码优化
** 第十章 早期（编译期）优化
*** 概述
*** javac编译器
**** javac的源码与调试
**** 解析与填充符号表
**** 注解处理器
**** 语义分析与字节码生成
*** java语法糖的味道
**** 泛型与类型擦除
**** 自动装箱、拆箱与遍历循环
**** 条件编译
*** 实战：插入式注解处理器
**** 实战目标
**** 代码实现
**** 运行与测试
**** 其他应用案例
** 第十一章 晚期（运行期）优化
*** 概述
*** HotSpot虚拟机内的即时编译器
**** 解释器与编译器
**** 编译对象与触发条件
**** 编译过程
**** 查看及分析即时编译结果
*** 编译优化技术
**** 优化技术概览
**** 公共子表达式消除
**** 数组便捷检查消除
**** 方法内联
**** 逃逸分析
*** Java与C/C++的编译器对比
*** 本章小结
* 第五部分 高效并发
** 第十二章 java内存模型与线程
*** 概述
*** 硬件的效率与一致性
*** java内存模型
**** 主内存与工作内存
**** 内存间交互操作
**** 对于volatile型变量的特殊规则
**** 对于long和double型变量的特殊规则
**** 原子性、可见性与有序性
**** 先行发生原则
*** java与线程
**** 线程的实现
**** java线程的调度
**** 状态转换
*** 本章小结
** 第十三章 线程安全与锁优化
*** 概述
*** 线程安全
**** java语言中的线程安全
**** 线程安全的实现方法
*** 锁优化
**** 自旋锁与自适应自旋锁
**** 锁消除
**** 锁粗话
**** 轻量级锁
**** 偏向锁
*** 本章小结
